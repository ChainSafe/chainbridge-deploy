package ethereum

import (
	"context"
	"errors"
	"fmt"
	"math/big"
	"time"

	"github.com/ChainSafe/ChainBridge/bindings/Bridge"
	"github.com/ChainSafe/ChainBridge/crypto/secp256k1"
	msg "github.com/ChainSafe/ChainBridge/message"
	"github.com/ChainSafe/ChainBridge/shared/ethereum"
	log "github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	ethtypes "github.com/ethereum/go-ethereum/core/types"
	"github.com/status-im/keycard-go/hexutils"
)

var BlockRetryInterval = time.Second * 3
var BlockRetryLimit = 20

type Client struct {
	client *utils.Client
	bridge common.Address
	erc20  common.Address
	stop   chan int
	log    log.Logger
}

func NewClient(url string, privateKey string, bridge, erc20 common.Address, log log.Logger) (*Client, error) {
	kp, err := secp256k1.NewKeypairFromString(privateKey)
	if err != nil {
		return nil, err
	}

	client, err := utils.NewClient(url, kp)
	if err != nil {
		return nil, err
	}

	return &Client{
		client: client,
		bridge: bridge,
		erc20:  erc20,
		log:    log,
	}, nil
}

// CreateFungibleDeposit submits a deposit to the bridge contract
func (c *Client) CreateFungibleDeposit(amount *big.Int, recipient string, rId msg.ResourceId, destId msg.ChainId) (msg.Nonce, *big.Int, error) {
	data := utils.ConstructErc20DepositData(hexutils.HexToBytes(recipient[2:]), amount)

	bridgeInstance, err := Bridge.NewBridge(c.bridge, c.client.Client)
	if err != nil {
		return 0, nil, err
	}

	err = c.client.LockNonceAndUpdate()
	if err != nil {
		return 0, nil, err
	}

	tx, err := bridgeInstance.Deposit(
		c.client.Opts,
		uint8(destId),
		rId,
		data,
	)

	c.client.UnlockNonce()

	if err != nil {
		return 0, nil, err
	}

	reciept, err := c.WaitForTx(tx)
	if err != nil {
		return 0, nil, err
	}

	nonce, err := c.parseDepositNonce(reciept)
	if err != nil {
		return 0, nil, err
	}

	return nonce, reciept.BlockNumber, nil
}

// parseDepositNonce retrieves the nonce generated by a deposit by querying the associated deposit event
func (c *Client) parseDepositNonce(receipt *ethtypes.Receipt) (msg.Nonce, error) {
	for _, r := range receipt.Logs {
		if r.Address != c.bridge {
			continue
		}

		if r.Topics[0] != utils.Deposit.GetTopic() {
			continue
		}

		return msg.Nonce(r.Topics[3].Big().Uint64()), nil
	}

	return 0, fmt.Errorf("deposit event not found for tx %s", receipt.TxHash.Hex())
}

// VerifyFungibleProposal waits for the proposal to be finalized, then verifies the resulting ERC20 Transfer event
func (c *Client) VerifyFungibleProposal(amount *big.Int, recipient string, source msg.ChainId, nonce msg.Nonce, startBlock *big.Int, status *big.Int) error {
	tx, err := c.WaitForEvent(utils.ProposalEvent, startBlock, nonce, source, status)
	if err != nil {
		return err
	}

	// confirm transfer event and params
	receipt, err := c.client.Client.TransactionReceipt(context.Background(), tx)
	if err != nil {
		return err
	}

	if receipt.Status != 1 {
		return fmt.Errorf("execution of proposal failed. tx: %s", receipt.TxHash.Hex())
	}

	for _, evt := range receipt.Logs {
		if evt.Topics[0] == Erc20TransferEvent.GetTopic() {
			ok, err := isExpectedErc20Event(*evt, amount, recipient)
			if err != nil {
				return err
			} else if ok {
				return nil
			}
		}
	}

	return fmt.Errorf("transfer event not found for tx %s", tx.Hex())

}

// WaitForEvent will wait for some event on the bridge contract.
// Note: Expects the nonce and source ID to be part of the event being watched.
func (c *Client) WaitForEvent(event utils.EventSig, startBlock *big.Int, nonce msg.Nonce, source msg.ChainId, status *big.Int) (common.Hash, error) {
	currentBlock := startBlock
	for retry := 0; retry < BlockRetryLimit; retry++ {

		err := c.WaitForBlock(currentBlock)
		if err != nil {
			return common.Hash{}, nil
		}

		query := ethereum.FilterQuery{
			FromBlock: currentBlock,
			ToBlock:   currentBlock,
			Addresses: []common.Address{c.bridge},
			Topics: [][]common.Hash{
				{event.GetTopic()},
			},
		}

		evts, err := c.client.Client.FilterLogs(context.Background(), query)
		if err != nil {
			return common.Hash{}, err
		}

		for _, evt := range evts {
			if isExpectedEvent(evt, nonce, source, status) {
				return evt.TxHash, nil
			}
		}

		currentBlock.Add(currentBlock, big.NewInt(1))
	}

	return common.Hash{}, fmt.Errorf("retries exceeded waiting for event")
}

// WaitForTx will retry some number of times until the tx is processed and then verifies the status in the receipt
func (c *Client) WaitForTx(tx *ethtypes.Transaction) (*ethtypes.Receipt, error) {
	retry := 10
	for retry > 0 {
		receipt, err := c.client.Client.TransactionReceipt(context.Background(), tx.Hash())
		if err != nil {
			retry--
			time.Sleep(time.Second * 1)
			continue
		}

		if receipt.Status != 1 {
			return nil, fmt.Errorf("transaction failed on chain")
		}
		return receipt, nil
	}
	return nil, fmt.Errorf("failed to wait for tx")
}

func (c *Client) WaitForBlock(block *big.Int) error {
	for {
		select {
		case <-c.stop:
			return errors.New("connection terminated")
		default:
			currBlock, err := c.client.Client.BlockByNumber(context.Background(), nil)
			if err != nil {
				return err
			}

			// Equal or greater than target
			if currBlock.Number().Cmp(block) >= 0 {
				return nil
			}
			c.log.Trace("Block not ready, waiting", "target", block, "current", currBlock)
			time.Sleep(BlockRetryInterval)
			continue
		}
	}
}

func (c *Client) Close() {
	c.client.Client.Close()
	close(c.stop)
}
