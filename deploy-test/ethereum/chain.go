package ethereum

import (
	"context"
	"errors"
	"fmt"
	"math/big"
	"time"

	"github.com/ChainSafe/ChainBridge/bindings/Bridge"
	"github.com/ChainSafe/ChainBridge/crypto/secp256k1"
	msg "github.com/ChainSafe/ChainBridge/message"
	"github.com/ChainSafe/ChainBridge/shared/ethereum"
	log "github.com/ChainSafe/log15"
	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	ethtypes "github.com/ethereum/go-ethereum/core/types"
	"github.com/status-im/keycard-go/hexutils"
)

var BlockRetryInterval = time.Second * 3
var BlockRetryLimit = 40

type Chain struct {
	ethClient    *utils.Client
	bridge       common.Address
	erc20        common.Address
	erc20Handler common.Address
	stop         chan int
	log          log.Logger
}

func NewChain(url string, privateKey string, bridge, erc20 common.Address, erc20Handler common.Address, log log.Logger) (*Chain, error) {
	kp, err := secp256k1.NewKeypairFromString(privateKey)
	if err != nil {
		return nil, err
	}

	client, err := utils.NewClient(url, kp)
	if err != nil {
		return nil, err
	}

	return &Chain{
		ethClient:    client,
		bridge:       bridge,
		erc20:        erc20,
		erc20Handler: erc20Handler,
		log:          log,
	}, nil
}

// CreateFungibleDeposit submits a deposit to the bridge contract
func (c *Chain) CreateFungibleDeposit(amount *big.Int, recipient string, rId msg.ResourceId, destId msg.ChainId) (msg.Nonce, error) {
	// First we have to approve the handler to spend the tokens
	err := utils.Erc20Approve(c.ethClient, c.erc20, c.erc20Handler, amount)
	if err != nil {
		return 0, err
	}

	data := utils.ConstructErc20DepositData(hexutils.HexToBytes(recipient[2:]), amount)
	bridgeInstance, err := Bridge.NewBridge(c.bridge, c.ethClient.Client)
	if err != nil {
		return 0, err
	}

	err = c.ethClient.LockNonceAndUpdate()
	if err != nil {
		return 0, err
	}

	tx, err := bridgeInstance.Deposit(
		c.ethClient.Opts,
		uint8(destId),
		rId,
		data,
	)

	c.ethClient.UnlockNonce()

	if err != nil {
		return 0, err
	}

	receipt, err := c.WaitForTx(tx)
	if err != nil {
		return 0, err
	}

	if receipt.Status != 1 {
		return 0, fmt.Errorf("fungible deposit transaction failed. Tx: %s", receipt.TxHash.Hex())
	}

	nonce, err := c.parseDepositNonce(receipt)
	if err != nil {
		return 0, err
	}

	return nonce, nil
}

// parseDepositNonce retrieves the nonce generated by a deposit by querying the associated deposit event
func (c *Chain) parseDepositNonce(receipt *ethtypes.Receipt) (msg.Nonce, error) {
	for _, r := range receipt.Logs {
		if r.Address != c.bridge {
			continue
		}

		if r.Topics[0] != utils.Deposit.GetTopic() {
			continue
		}

		return msg.Nonce(r.Topics[3].Big().Uint64()), nil
	}

	return 0, fmt.Errorf("deposit event not found for tx %s", receipt.TxHash.Hex())
}

// VerifyFungibleProposal waits for the proposal to be finalized, then verifies the resulting ERC20 Transfer event
func (c *Chain) VerifyFungibleProposal(amount *big.Int, recipient string, source msg.ChainId, nonce msg.Nonce) error {

	startBlock, err := c.ethClient.Client.BlockByNumber(context.Background(), nil)
	if err != nil {
		return err
	}

	// Waiting for the proposal to be executed
	tx, err := c.WaitForProposalEvent(startBlock.Number(), nonce, source, utils.Executed)
	if err != nil {
		return err
	}

	// confirm transfer event and params
	receipt, err := c.ethClient.Client.TransactionReceipt(context.Background(), tx)
	if err != nil {
		return err
	}

	if receipt.Status != 1 {
		return fmt.Errorf("execution of proposal failed. tx: %s", receipt.TxHash.Hex())
	}

	for _, evt := range receipt.Logs {
		if evt.Topics[0] == Erc20TransferEvent.GetTopic() {
			ok, err := isExpectedErc20Event(*evt, amount, recipient)
			if err != nil {
				return err
			} else if ok {
				return nil
			}
		}
	}

	return fmt.Errorf("transfer event not found for tx %s", tx.Hex())

}

// WaitForProposalEvent will wait for some event on the bridge contract.
// Note: Expects the nonce and source ID to be part of the event being watched.
func (c *Chain) WaitForProposalEvent(startBlock *big.Int, nonce msg.Nonce, source msg.ChainId, status utils.ProposalStatus) (common.Hash, error) {
	currentBlock := startBlock
	for retry := 0; retry < BlockRetryLimit; retry++ {

		err := c.WaitForBlock(currentBlock)
		if err != nil {
			return common.Hash{}, nil
		}

		query := ethereum.FilterQuery{
			FromBlock: currentBlock,
			ToBlock:   currentBlock,
			Addresses: []common.Address{c.bridge},
			Topics: [][]common.Hash{
				{utils.ProposalEvent.GetTopic()},
			},
		}
		log.Debug("Processing block for events", "block", currentBlock.String())
		evts, err := c.ethClient.Client.FilterLogs(context.Background(), query)
		if err != nil {
			return common.Hash{}, err
		}

		for _, evt := range evts {
			if isExpectedProposalEvent(evt, nonce, source, big.NewInt(int64(status))) {
				return evt.TxHash, nil
			} else {
				log.Debug("Proposal status updated", "status", statusString(evt.Topics[3].Big().Uint64()))
			}
		}

		currentBlock.Add(currentBlock, big.NewInt(1))
	}

	return common.Hash{}, fmt.Errorf("retries exceeded waiting for proposal event")
}

// WaitForTx will retry some number of times until the tx is processed and then verifies the status in the receipt
func (c *Chain) WaitForTx(tx *ethtypes.Transaction) (*ethtypes.Receipt, error) {
	retry := 10
	for retry > 0 {
		receipt, err := c.ethClient.Client.TransactionReceipt(context.Background(), tx.Hash())
		if err != nil {
			retry--
			time.Sleep(time.Second * 1)
			continue
		}

		if receipt.Status != 1 {
			return nil, fmt.Errorf("transaction failed on chain")
		}
		return receipt, nil
	}
	return nil, fmt.Errorf("failed to wait for tx")
}

func (c *Chain) WaitForBlock(block *big.Int) error {
	for {
		select {
		case <-c.stop:
			return errors.New("connection terminated")
		default:
			currBlock, err := c.ethClient.Client.BlockByNumber(context.Background(), nil)
			if err != nil {
				return err
			}

			// Equal or greater than target
			if currBlock.Number().Cmp(block) >= 0 {
				return nil
			}
			c.log.Trace("Block not ready, waiting", "target", block, "current", currBlock.Number())
			time.Sleep(BlockRetryInterval)
			continue
		}
	}
}

func (c *Chain) Close() {
	c.ethClient.Client.Close()
	close(c.stop)
}
